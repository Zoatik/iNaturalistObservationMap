<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Miku Tile Viewer ðŸ’™</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .leaflet-popup-content { font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  </style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<!-- Gzip decoder -->
<script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<script>
const map = L.map('map', { preferCanvas: true }).setView([46.82, 8.23], 7);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; OpenStreetMap'
}).addTo(map);

// Tile URL template for your generated tiles:
const TILE_URL = 'tiles/{z}/{x}/{y}.geojson.gz';
const MIN_Z = 5, MAX_Z = 12;

// Keep a cache of active tile layers so we don't double-load.
const activeTiles = new Map();

function zxyKey(z, x, y){ return `${z}/${x}/${y}`; }

// Convert lat/lng to tile x/y at zoom z
function lonLatToTile(lon, lat, z) {
  lat = Math.max(Math.min(lat, 85.05112878), -85.05112878);
  const x = Math.floor((lon + 180.0) / 360.0 * Math.pow(2, z));
  const s = Math.sin(lat * Math.PI / 180.0);
  const y = Math.floor((1.0 - Math.log((1.0 + s) / (1.0 - s)) / Math.PI) / 2.0 * Math.pow(2, z));
  return [x, y];
}

// Figure out visible tiles at the current zoom
function visibleTiles(z) {
  const b = map.getBounds();
  const sw = b.getSouthWest();
  const ne = b.getNorthEast();
  const [xMin, yMax] = lonLatToTile(sw.lng, sw.lat, z);
  const [xMax, yMin] = lonLatToTile(ne.lng, ne.lat, z);

  const tiles = [];
  for (let x = Math.min(xMin, xMax); x <= Math.max(xMin, xMax); x++) {
    for (let y = Math.min(yMin, yMax); y <= Math.max(yMin, yMax); y++) {
      tiles.push([z, x, y]);
    }
  }
  return tiles;
}

async function loadTile(z, x, y) {
  const key = zxyKey(z, x, y);
  if (activeTiles.has(key)) return;

  const url = TILE_URL.replace('{z}', z).replace('{x}', x).replace('{y}', y);
  try {
    const resp = await fetch(url);
    if (!resp.ok) return; // tile not present
    const buf = await resp.arrayBuffer();
    const ungz = pako.ungzip(new Uint8Array(buf), { to: 'string' });
    const gj = JSON.parse(ungz);

    const layer = L.geoJSON(gj, {
      pointToLayer: (feat, latlng) => {
        return L.circleMarker(latlng, {
          radius: 3,
          weight: 0,
          fillOpacity: 0.7
        });
      },
      onEachFeature: (feat, layer) => {
        const p = feat.properties || {};
        const taxon = p.taxon_id ?? 'â€”';
        const link = taxon ? `<br><a href="https://www.inaturalist.org/taxa/${taxon}" target="_blank" rel="noopener">View on iNaturalist</a>` : '';
        layer.bindPopup(
          `<b>Observation:</b> ${p.observation_uuid || 'â€”'}<br>` +
          `Taxon ID: ${taxon || 'â€”'}${link}<br>` +
          `Quality: ${p.quality_grade || 'â€”'}<br>` +
          `Observed on: ${p.observed_on || 'â€”'}<br>` +
          `Observer ID: ${p.observer_id || 'â€”'}<br>` +
          `Positional accuracy: ${p.positional_accuracy || 'â€”'} m`
        );
        layer.bindTooltip(`Taxon ${taxon} â€¢ ${p.quality_grade || 'â€”'}`);
      }
    }).addTo(map);

    activeTiles.set(key, layer);
  } catch (e) {
    // ignore missing/failed tiles
  }
}

function unloadTilesNotVisible(visibleSet) {
  for (const [key, layer] of activeTiles.entries()) {
    if (!visibleSet.has(key)) {
      map.removeLayer(layer);
      activeTiles.delete(key);
    }
  }
}

function updateTiles() {
  let z = map.getZoom();
  z = Math.max(MIN_Z, Math.min(MAX_Z, Math.round(z)));
  const tiles = visibleTiles(z);
  const vs = new Set(tiles.map(t => zxyKey(...t)));
  unloadTilesNotVisible(vs);
  tiles.forEach(([zz, xx, yy]) => loadTile(zz, xx, yy));
}

map.on('moveend zoomend', updateTiles);
updateTiles();
</script>
</body>
</html>
